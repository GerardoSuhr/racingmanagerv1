{"ast":null,"code":"// src/utils/generateCircuitSVG.js\n\nexport function generateCircuitSVG(sectors, miniSectors, options = {}) {\n  var _options$speed;\n  const padding = 50;\n  const debugPoints = [];\n  const points = [];\n  const speeds = [];\n  const pathParts = [];\n  let x = 0;\n  let y = 0;\n  let angle = 0; // in degrees\n\n  const scale = 1; // 1 meter = 1 unit for now\n  const carSpeedKmh = (_options$speed = options.speed) !== null && _options$speed !== void 0 ? _options$speed : 100;\n  const intervalMs = 30;\n  const getSpeedFactor = radius => {\n    if (!radius) return 1;\n    return Math.min(0.99, Math.max(0.5, (radius - 100) / 200 * (0.99 - 0.5) + 0.5));\n  };\n  const toRadians = deg => deg * Math.PI / 180;\n  const toDegrees = rad => rad * 180 / Math.PI;\n  const addPoint = (px, py, speed) => {\n    points.push({\n      x: px,\n      y: py\n    });\n    speeds.push(speed);\n  };\n  const orderedMiniSectors = sectors.flatMap(sector => sector.mini_sector_ids.map(id => miniSectors.find(ms => ms.id === id))).filter(Boolean);\n  for (let ms of orderedMiniSectors) {\n    const length = ms.length_cm / 100;\n    const radius = ms.curvature_radius_cm / 100;\n    const speedFactor = getSpeedFactor(radius);\n    const speedKmh = carSpeedKmh * speedFactor;\n    const speedMps = speedKmh * 1000 / 3600;\n    const distancePerStep = speedMps * (intervalMs / 1000);\n    if (radius === 0) {\n      // Recta\n      const dx = length * Math.cos(toRadians(angle));\n      const dy = length * Math.sin(toRadians(angle));\n      const steps = Math.max(1, Math.floor(length / distancePerStep));\n      for (let i = 0; i <= steps; i++) {\n        const px = x + dx * i / steps;\n        const py = y + dy * i / steps;\n        addPoint(px, py, speedKmh);\n      }\n      pathParts.push(`L ${x + dx} ${y + dy}`);\n      x += dx;\n      y += dy;\n    } else {\n      var _ms$arc_angle_deg;\n      // Curva\n      const arcAngle = (_ms$arc_angle_deg = ms.arc_angle_deg) !== null && _ms$arc_angle_deg !== void 0 ? _ms$arc_angle_deg : 180;\n      const steps = Math.max(1, Math.floor(radius * toRadians(arcAngle) / distancePerStep));\n      const clockwise = ms.curve_direction === 'clockwise';\n      const sign = clockwise ? 1 : -1;\n      const startAngle = toRadians(angle);\n      const cx = x + radius * Math.cos(startAngle + sign * Math.PI / 2);\n      const cy = y + radius * Math.sin(startAngle + sign * Math.PI / 2);\n      for (let i = 1; i <= steps; i++) {\n        const theta = toRadians(arcAngle) * (i / steps);\n        const angleStep = startAngle + sign * theta;\n        const px = cx + radius * Math.cos(angleStep - sign * Math.PI / 2);\n        const py = cy + radius * Math.sin(angleStep - sign * Math.PI / 2);\n        addPoint(px, py, speedKmh);\n      }\n      const endAngle = startAngle + sign * toRadians(arcAngle);\n      x = cx + radius * Math.cos(endAngle - sign * Math.PI / 2);\n      y = cy + radius * Math.sin(endAngle - sign * Math.PI / 2);\n      angle += sign * arcAngle;\n      const largeArcFlag = arcAngle > 180 ? 1 : 0;\n      const sweepFlag = clockwise ? 1 : 0;\n      pathParts.push(`A ${radius} ${radius} 0 ${largeArcFlag} ${sweepFlag} ${x} ${y}`);\n    }\n    debugPoints.push({\n      x,\n      y\n    });\n  }\n  const minX = Math.min(...points.map(p => p.x));\n  const minY = Math.min(...points.map(p => p.y));\n  const maxX = Math.max(...points.map(p => p.x));\n  const maxY = Math.max(...points.map(p => p.y));\n  const offsetX = padding - minX;\n  const offsetY = padding - minY;\n  const translatedPath = pathParts.map(part => {\n    return part.replace(/([0-9.-]+) ([0-9.-]+)/g, (_, a, b) => {\n      return `${parseFloat(a) + offsetX} ${parseFloat(b) + offsetY}`;\n    });\n  });\n  const translatedPoints = points.map(p => ({\n    x: p.x + offsetX,\n    y: p.y + offsetY\n  }));\n  const translatedDebugPoints = debugPoints.map(p => ({\n    x: p.x + offsetX,\n    y: p.y + offsetY\n  }));\n  const startLine = {\n    x1: translatedPoints[0].x - 5,\n    y1: translatedPoints[0].y - 5,\n    x2: translatedPoints[0].x + 5,\n    y2: translatedPoints[0].y + 5\n  };\n  return {\n    path: `M ${translatedPoints[0].x} ${translatedPoints[0].y} ` + translatedPath.join(' '),\n    startLine,\n    debugPoints: translatedDebugPoints,\n    bounds: {\n      width: maxX - minX + 2 * padding,\n      height: maxY - minY + 2 * padding\n    },\n    carPoints: translatedPoints,\n    carSpeeds: speeds\n  };\n}","map":{"version":3,"names":["generateCircuitSVG","sectors","miniSectors","options","_options$speed","padding","debugPoints","points","speeds","pathParts","x","y","angle","scale","carSpeedKmh","speed","intervalMs","getSpeedFactor","radius","Math","min","max","toRadians","deg","PI","toDegrees","rad","addPoint","px","py","push","orderedMiniSectors","flatMap","sector","mini_sector_ids","map","id","find","ms","filter","Boolean","length","length_cm","curvature_radius_cm","speedFactor","speedKmh","speedMps","distancePerStep","dx","cos","dy","sin","steps","floor","i","_ms$arc_angle_deg","arcAngle","arc_angle_deg","clockwise","curve_direction","sign","startAngle","cx","cy","theta","angleStep","endAngle","largeArcFlag","sweepFlag","minX","p","minY","maxX","maxY","offsetX","offsetY","translatedPath","part","replace","_","a","b","parseFloat","translatedPoints","translatedDebugPoints","startLine","x1","y1","x2","y2","path","join","bounds","width","height","carPoints","carSpeeds"],"sources":["C:/Users/gerar/Documents/Proyectos/Racing Manager/V1/frontend/src/utils/generateCircuitSVG.js"],"sourcesContent":["// src/utils/generateCircuitSVG.js\r\n\r\nexport function generateCircuitSVG(sectors, miniSectors, options = {}) {\r\n    const padding = 50;\r\n    const debugPoints = [];\r\n    const points = [];\r\n    const speeds = [];\r\n    const pathParts = [];\r\n  \r\n    let x = 0;\r\n    let y = 0;\r\n    let angle = 0; // in degrees\r\n  \r\n    const scale = 1; // 1 meter = 1 unit for now\r\n    const carSpeedKmh = options.speed ?? 100;\r\n    const intervalMs = 30;\r\n  \r\n    const getSpeedFactor = (radius) => {\r\n      if (!radius) return 1;\r\n      return Math.min(0.99, Math.max(0.5, ((radius - 100) / 200) * (0.99 - 0.5) + 0.5));\r\n    };\r\n  \r\n    const toRadians = (deg) => (deg * Math.PI) / 180;\r\n    const toDegrees = (rad) => (rad * 180) / Math.PI;\r\n  \r\n    const addPoint = (px, py, speed) => {\r\n      points.push({ x: px, y: py });\r\n      speeds.push(speed);\r\n    };\r\n  \r\n    const orderedMiniSectors = sectors\r\n      .flatMap(sector => sector.mini_sector_ids.map(id => miniSectors.find(ms => ms.id === id)))\r\n      .filter(Boolean);\r\n  \r\n    for (let ms of orderedMiniSectors) {\r\n      const length = ms.length_cm / 100;\r\n      const radius = ms.curvature_radius_cm / 100;\r\n      const speedFactor = getSpeedFactor(radius);\r\n      const speedKmh = carSpeedKmh * speedFactor;\r\n      const speedMps = speedKmh * 1000 / 3600;\r\n      const distancePerStep = speedMps * (intervalMs / 1000);\r\n  \r\n      if (radius === 0) {\r\n        // Recta\r\n        const dx = length * Math.cos(toRadians(angle));\r\n        const dy = length * Math.sin(toRadians(angle));\r\n        const steps = Math.max(1, Math.floor(length / distancePerStep));\r\n        for (let i = 0; i <= steps; i++) {\r\n          const px = x + (dx * i) / steps;\r\n          const py = y + (dy * i) / steps;\r\n          addPoint(px, py, speedKmh);\r\n        }\r\n        pathParts.push(`L ${x + dx} ${y + dy}`);\r\n        x += dx;\r\n        y += dy;\r\n      } else {\r\n        // Curva\r\n        const arcAngle = ms.arc_angle_deg ?? 180;\r\n        const steps = Math.max(1, Math.floor((radius * toRadians(arcAngle)) / distancePerStep));\r\n        const clockwise = ms.curve_direction === 'clockwise';\r\n        const sign = clockwise ? 1 : -1;\r\n  \r\n        const startAngle = toRadians(angle);\r\n        const cx = x + radius * Math.cos(startAngle + sign * Math.PI / 2);\r\n        const cy = y + radius * Math.sin(startAngle + sign * Math.PI / 2);\r\n  \r\n        for (let i = 1; i <= steps; i++) {\r\n          const theta = toRadians(arcAngle) * (i / steps);\r\n          const angleStep = startAngle + sign * theta;\r\n          const px = cx + radius * Math.cos(angleStep - sign * Math.PI / 2);\r\n          const py = cy + radius * Math.sin(angleStep - sign * Math.PI / 2);\r\n          addPoint(px, py, speedKmh);\r\n        }\r\n  \r\n        const endAngle = startAngle + sign * toRadians(arcAngle);\r\n        x = cx + radius * Math.cos(endAngle - sign * Math.PI / 2);\r\n        y = cy + radius * Math.sin(endAngle - sign * Math.PI / 2);\r\n        angle += sign * arcAngle;\r\n  \r\n        const largeArcFlag = arcAngle > 180 ? 1 : 0;\r\n        const sweepFlag = clockwise ? 1 : 0;\r\n        pathParts.push(`A ${radius} ${radius} 0 ${largeArcFlag} ${sweepFlag} ${x} ${y}`);\r\n      }\r\n  \r\n      debugPoints.push({ x, y });\r\n    }\r\n  \r\n    const minX = Math.min(...points.map(p => p.x));\r\n    const minY = Math.min(...points.map(p => p.y));\r\n    const maxX = Math.max(...points.map(p => p.x));\r\n    const maxY = Math.max(...points.map(p => p.y));\r\n  \r\n    const offsetX = padding - minX;\r\n    const offsetY = padding - minY;\r\n  \r\n    const translatedPath = pathParts.map(part => {\r\n      return part.replace(/([0-9.-]+) ([0-9.-]+)/g, (_, a, b) => {\r\n        return `${parseFloat(a) + offsetX} ${parseFloat(b) + offsetY}`;\r\n      });\r\n    });\r\n  \r\n    const translatedPoints = points.map(p => ({ x: p.x + offsetX, y: p.y + offsetY }));\r\n    const translatedDebugPoints = debugPoints.map(p => ({ x: p.x + offsetX, y: p.y + offsetY }));\r\n  \r\n    const startLine = {\r\n      x1: translatedPoints[0].x - 5,\r\n      y1: translatedPoints[0].y - 5,\r\n      x2: translatedPoints[0].x + 5,\r\n      y2: translatedPoints[0].y + 5\r\n    };\r\n  \r\n    return {\r\n      path: `M ${translatedPoints[0].x} ${translatedPoints[0].y} ` + translatedPath.join(' '),\r\n      startLine,\r\n      debugPoints: translatedDebugPoints,\r\n      bounds: {\r\n        width: maxX - minX + 2 * padding,\r\n        height: maxY - minY + 2 * padding,\r\n      },\r\n      carPoints: translatedPoints,\r\n      carSpeeds: speeds\r\n    };\r\n  }"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}