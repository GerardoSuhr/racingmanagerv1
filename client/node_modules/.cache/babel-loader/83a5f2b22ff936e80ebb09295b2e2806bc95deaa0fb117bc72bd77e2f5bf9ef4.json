{"ast":null,"code":"export function generateCircuitSVG(sectors, miniSectors, options = {}) {\n  var _options$speed;\n  const padding = 50;\n  const points = [];\n  const speeds = [];\n  const pathParts = [];\n  const sectorStartData = [];\n  let x = 0;\n  let y = 0;\n  let angle = 0;\n  const carSpeedKmh = (_options$speed = options.speed) !== null && _options$speed !== void 0 ? _options$speed : 100;\n  const intervalMs = 30;\n  const getSpeedFactor = radius => {\n    if (!radius) return 1;\n    return Math.min(0.99, Math.max(0.5, (radius - 100) / 200 * (0.99 - 0.5) + 0.5));\n  };\n  const toRadians = deg => deg * Math.PI / 180;\n  const addPoint = (px, py, speed) => {\n    points.push({\n      x: px,\n      y: py\n    });\n    speeds.push(speed);\n  };\n  const orderedMiniSectors = sectors.flatMap(sector => sector.mini_sector_ids.map(id => miniSectors.find(ms => ms.id === id))).filter(Boolean);\n  const translatedStartData = [];\n\n  // ðŸ§ª Debug por sector (para circuito 1)\n  const debug = {\n    sector1: {\n      total: 0,\n      curvas: 0,\n      rectas: 0\n    },\n    sector2: {\n      total: 0,\n      curvas: 0,\n      rectas: 0\n    }\n  };\n  let currentSector = 1;\n  let sectorIndex = 0;\n  let miniSectorIndex = 0;\n  for (let ms of orderedMiniSectors) {\n    var _ms$arc_angle_deg, _sectors$sectorIndex;\n    const length = ms.length_cm / 100;\n    const radius = ms.curvature_radius_cm / 100;\n    const arcAngle = (_ms$arc_angle_deg = ms.arc_angle_deg) !== null && _ms$arc_angle_deg !== void 0 ? _ms$arc_angle_deg : 180;\n    const speedFactor = getSpeedFactor(radius);\n    const speedKmh = carSpeedKmh * speedFactor;\n    const speedMps = speedKmh * 1000 / 3600;\n    const distancePerStep = speedMps * (intervalMs / 1000);\n    const currentIndex = points.length;\n\n    // ðŸ‘‡ IdentificaciÃ³n por minisector para debug en circuito 1\n    if (miniSectors.length === 4) {\n      if (ms.id === 1 || ms.id === 2) currentSector = 1;else currentSector = 2;\n    }\n    if (radius === 0) {\n      const dx = length * Math.cos(toRadians(angle));\n      const dy = length * Math.sin(toRadians(angle));\n      const steps = Math.max(1, Math.floor(length / distancePerStep));\n      for (let i = 0; i <= steps; i++) {\n        const px = x + dx * i / steps;\n        const py = y + dy * i / steps;\n        addPoint(px, py, speedKmh);\n      }\n      pathParts.push(`L ${x + dx} ${y + dy}`);\n      x += dx;\n      y += dy;\n\n      // Debug\n      debug[`sector${currentSector}`].rectas += steps;\n      debug[`sector${currentSector}`].total += steps;\n    } else {\n      const steps = Math.max(1, Math.floor(radius * toRadians(arcAngle) / distancePerStep));\n      const clockwise = ms.curve_direction === 'clockwise';\n      const sign = clockwise ? 1 : -1;\n      const startAngle = toRadians(angle);\n      const cx = x + radius * Math.cos(startAngle + sign * Math.PI / 2);\n      const cy = y + radius * Math.sin(startAngle + sign * Math.PI / 2);\n      for (let i = 1; i <= steps; i++) {\n        const theta = toRadians(arcAngle) * (i / steps);\n        const angleStep = startAngle + sign * theta;\n        const px = cx + radius * Math.cos(angleStep - sign * Math.PI / 2);\n        const py = cy + radius * Math.sin(angleStep - sign * Math.PI / 2);\n        addPoint(px, py, speedKmh);\n      }\n      const endAngle = startAngle + sign * toRadians(arcAngle);\n      x = cx + radius * Math.cos(endAngle - sign * Math.PI / 2);\n      y = cy + radius * Math.sin(endAngle - sign * Math.PI / 2);\n      angle += sign * arcAngle;\n      const largeArcFlag = arcAngle > 180 ? 1 : 0;\n      const sweepFlag = clockwise ? 1 : 0;\n      pathParts.push(`A ${radius} ${radius} 0 ${largeArcFlag} ${sweepFlag} ${x} ${y}`);\n\n      // Debug\n      debug[`sector${currentSector}`].curvas += steps;\n      debug[`sector${currentSector}`].total += steps;\n    }\n\n    // Marca el inicio del sector\n    const nextMiniSector = orderedMiniSectors[miniSectorIndex + 1];\n    if (nextMiniSector && sectors[sectorIndex] && sectors[sectorIndex].mini_sector_ids.includes(nextMiniSector.id)) {\n      translatedStartData.push({\n        x: points[currentIndex].x,\n        y: points[currentIndex].y,\n        index: currentIndex\n      });\n    }\n\n    // Avanza contador de sector\n    if (sectorIndex < sectors.length && ms.id === ((_sectors$sectorIndex = sectors[sectorIndex]) === null || _sectors$sectorIndex === void 0 ? void 0 : _sectors$sectorIndex.mini_sector_ids.at(-1))) {\n      sectorIndex++;\n    }\n    miniSectorIndex++;\n  }\n  console.log('Sector 1:', debug.sector1);\n  console.log('Sector 2:', debug.sector2);\n  console.log('Sector start indices:', translatedStartData.map(p => p.index));\n  const minX = Math.min(...points.map(p => p.x));\n  const minY = Math.min(...points.map(p => p.y));\n  const maxX = Math.max(...points.map(p => p.x));\n  const maxY = Math.max(...points.map(p => p.y));\n  const offsetX = padding - minX;\n  const offsetY = padding - minY;\n  const translatedPath = pathParts.map(part => {\n    return part.replace(/([0-9.-]+) ([0-9.-]+)/g, (_, a, b) => {\n      return `${parseFloat(a) + offsetX} ${parseFloat(b) + offsetY}`;\n    });\n  });\n  const translatedPoints = points.map(p => ({\n    x: p.x + offsetX,\n    y: p.y + offsetY\n  }));\n  const startLine = {\n    x1: translatedPoints[0].x - 5,\n    y1: translatedPoints[0].y - 5,\n    x2: translatedPoints[0].x + 5,\n    y2: translatedPoints[0].y + 5\n  };\n  return {\n    path: `M ${translatedPoints[0].x} ${translatedPoints[0].y} ` + translatedPath.join(' '),\n    startLine,\n    bounds: {\n      width: maxX - minX + 2 * padding,\n      height: maxY - minY + 2 * padding\n    },\n    carPoints: translatedPoints,\n    carSpeeds: speeds,\n    sectorStartPoints: translatedStartData\n  };\n}","map":{"version":3,"names":["generateCircuitSVG","sectors","miniSectors","options","_options$speed","padding","points","speeds","pathParts","sectorStartData","x","y","angle","carSpeedKmh","speed","intervalMs","getSpeedFactor","radius","Math","min","max","toRadians","deg","PI","addPoint","px","py","push","orderedMiniSectors","flatMap","sector","mini_sector_ids","map","id","find","ms","filter","Boolean","translatedStartData","debug","sector1","total","curvas","rectas","sector2","currentSector","sectorIndex","miniSectorIndex","_ms$arc_angle_deg","_sectors$sectorIndex","length","length_cm","curvature_radius_cm","arcAngle","arc_angle_deg","speedFactor","speedKmh","speedMps","distancePerStep","currentIndex","dx","cos","dy","sin","steps","floor","i","clockwise","curve_direction","sign","startAngle","cx","cy","theta","angleStep","endAngle","largeArcFlag","sweepFlag","nextMiniSector","includes","index","at","console","log","p","minX","minY","maxX","maxY","offsetX","offsetY","translatedPath","part","replace","_","a","b","parseFloat","translatedPoints","startLine","x1","y1","x2","y2","path","join","bounds","width","height","carPoints","carSpeeds","sectorStartPoints"],"sources":["C:/Users/gerar/Documents/Proyectos/Racing Manager/V1/frontend/src/utils/generateCircuitSVG.js"],"sourcesContent":["export function generateCircuitSVG(sectors, miniSectors, options = {}) {\r\n  const padding = 50;\r\n  const points = [];\r\n  const speeds = [];\r\n  const pathParts = [];\r\n\r\n  const sectorStartData = [];\r\n\r\n  let x = 0;\r\n  let y = 0;\r\n  let angle = 0;\r\n\r\n  const carSpeedKmh = options.speed ?? 100;\r\n  const intervalMs = 30;\r\n\r\n  const getSpeedFactor = (radius) => {\r\n    if (!radius) return 1;\r\n    return Math.min(0.99, Math.max(0.5, ((radius - 100) / 200) * (0.99 - 0.5) + 0.5));\r\n  };\r\n\r\n  const toRadians = (deg) => (deg * Math.PI) / 180;\r\n\r\n  const addPoint = (px, py, speed) => {\r\n    points.push({ x: px, y: py });\r\n    speeds.push(speed);\r\n  };\r\n\r\n  const orderedMiniSectors = sectors\r\n    .flatMap(sector => sector.mini_sector_ids.map(id => miniSectors.find(ms => ms.id === id)))\r\n    .filter(Boolean);\r\n\r\n  const translatedStartData = [];\r\n\r\n  // ðŸ§ª Debug por sector (para circuito 1)\r\n  const debug = {\r\n    sector1: { total: 0, curvas: 0, rectas: 0 },\r\n    sector2: { total: 0, curvas: 0, rectas: 0 }\r\n  };\r\n  let currentSector = 1;\r\n\r\n  let sectorIndex = 0;\r\n  let miniSectorIndex = 0;\r\n\r\n  for (let ms of orderedMiniSectors) {\r\n    const length = ms.length_cm / 100;\r\n    const radius = ms.curvature_radius_cm / 100;\r\n    const arcAngle = ms.arc_angle_deg ?? 180;\r\n    const speedFactor = getSpeedFactor(radius);\r\n    const speedKmh = carSpeedKmh * speedFactor;\r\n    const speedMps = speedKmh * 1000 / 3600;\r\n    const distancePerStep = speedMps * (intervalMs / 1000);\r\n\r\n    const currentIndex = points.length;\r\n\r\n    // ðŸ‘‡ IdentificaciÃ³n por minisector para debug en circuito 1\r\n    if (miniSectors.length === 4) {\r\n      if (ms.id === 1 || ms.id === 2) currentSector = 1;\r\n      else currentSector = 2;\r\n    }\r\n\r\n    if (radius === 0) {\r\n      const dx = length * Math.cos(toRadians(angle));\r\n      const dy = length * Math.sin(toRadians(angle));\r\n      const steps = Math.max(1, Math.floor(length / distancePerStep));\r\n\r\n      for (let i = 0; i <= steps; i++) {\r\n        const px = x + (dx * i) / steps;\r\n        const py = y + (dy * i) / steps;\r\n        addPoint(px, py, speedKmh);\r\n      }\r\n\r\n      pathParts.push(`L ${x + dx} ${y + dy}`);\r\n      x += dx;\r\n      y += dy;\r\n\r\n      // Debug\r\n      debug[`sector${currentSector}`].rectas += steps;\r\n      debug[`sector${currentSector}`].total += steps;\r\n\r\n    } else {\r\n      const steps = Math.max(1, Math.floor((radius * toRadians(arcAngle)) / distancePerStep));\r\n      const clockwise = ms.curve_direction === 'clockwise';\r\n      const sign = clockwise ? 1 : -1;\r\n\r\n      const startAngle = toRadians(angle);\r\n      const cx = x + radius * Math.cos(startAngle + sign * Math.PI / 2);\r\n      const cy = y + radius * Math.sin(startAngle + sign * Math.PI / 2);\r\n\r\n      for (let i = 1; i <= steps; i++) {\r\n        const theta = toRadians(arcAngle) * (i / steps);\r\n        const angleStep = startAngle + sign * theta;\r\n        const px = cx + radius * Math.cos(angleStep - sign * Math.PI / 2);\r\n        const py = cy + radius * Math.sin(angleStep - sign * Math.PI / 2);\r\n        addPoint(px, py, speedKmh);\r\n      }\r\n\r\n      const endAngle = startAngle + sign * toRadians(arcAngle);\r\n      x = cx + radius * Math.cos(endAngle - sign * Math.PI / 2);\r\n      y = cy + radius * Math.sin(endAngle - sign * Math.PI / 2);\r\n      angle += sign * arcAngle;\r\n\r\n      const largeArcFlag = arcAngle > 180 ? 1 : 0;\r\n      const sweepFlag = clockwise ? 1 : 0;\r\n      pathParts.push(`A ${radius} ${radius} 0 ${largeArcFlag} ${sweepFlag} ${x} ${y}`);\r\n\r\n      // Debug\r\n      debug[`sector${currentSector}`].curvas += steps;\r\n      debug[`sector${currentSector}`].total += steps;\r\n    }\r\n\r\n    // Marca el inicio del sector\r\n    const nextMiniSector = orderedMiniSectors[miniSectorIndex + 1];\r\n    if (\r\n      nextMiniSector &&\r\n      sectors[sectorIndex] &&\r\n      sectors[sectorIndex].mini_sector_ids.includes(nextMiniSector.id)\r\n    ) {\r\n      translatedStartData.push({\r\n        x: points[currentIndex].x,\r\n        y: points[currentIndex].y,\r\n        index: currentIndex\r\n      });\r\n    }\r\n\r\n    // Avanza contador de sector\r\n    if (\r\n      sectorIndex < sectors.length &&\r\n      ms.id === sectors[sectorIndex]?.mini_sector_ids.at(-1)\r\n    ) {\r\n      sectorIndex++;\r\n    }\r\n\r\n    miniSectorIndex++;\r\n  }\r\n\r\n  console.log('Sector 1:', debug.sector1);\r\n  console.log('Sector 2:', debug.sector2);\r\n  console.log('Sector start indices:', translatedStartData.map(p => p.index));\r\n\r\n  const minX = Math.min(...points.map(p => p.x));\r\n  const minY = Math.min(...points.map(p => p.y));\r\n  const maxX = Math.max(...points.map(p => p.x));\r\n  const maxY = Math.max(...points.map(p => p.y));\r\n\r\n  const offsetX = padding - minX;\r\n  const offsetY = padding - minY;\r\n\r\n  const translatedPath = pathParts.map(part => {\r\n    return part.replace(/([0-9.-]+) ([0-9.-]+)/g, (_, a, b) => {\r\n      return `${parseFloat(a) + offsetX} ${parseFloat(b) + offsetY}`;\r\n    });\r\n  });\r\n\r\n  const translatedPoints = points.map(p => ({\r\n    x: p.x + offsetX,\r\n    y: p.y + offsetY\r\n  }));\r\n\r\n  const startLine = {\r\n    x1: translatedPoints[0].x - 5,\r\n    y1: translatedPoints[0].y - 5,\r\n    x2: translatedPoints[0].x + 5,\r\n    y2: translatedPoints[0].y + 5\r\n  };\r\n\r\n  return {\r\n    path: `M ${translatedPoints[0].x} ${translatedPoints[0].y} ` + translatedPath.join(' '),\r\n    startLine,\r\n    bounds: {\r\n      width: maxX - minX + 2 * padding,\r\n      height: maxY - minY + 2 * padding\r\n    },\r\n    carPoints: translatedPoints,\r\n    carSpeeds: speeds,\r\n    sectorStartPoints: translatedStartData\r\n  };\r\n}"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}