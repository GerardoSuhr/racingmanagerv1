{"ast":null,"code":"export function generateCircuitSVG(sectors, miniSectors) {\n  const path = [];\n  const debugPoints = [];\n  let x = 0,\n    y = 0;\n  let angle = 0; // en grados\n\n  const toRadians = deg => deg * Math.PI / 180;\n  //const toDegrees = rad => rad * 180 / Math.PI;\n\n  // Usamos los mini sectores en el orden que definan los sectores\n  const orderedMiniSectors = sectors.flatMap(sector => sector.mini_sector_ids).map(id => miniSectors.find(ms => ms.id === id)).filter(Boolean);\n  const moveTo = (nx, ny) => {\n    path.push(`M ${nx} ${ny}`);\n    debugPoints.push({\n      x: nx,\n      y: ny\n    });\n  };\n  const lineTo = (nx, ny) => {\n    path.push(`L ${nx} ${ny}`);\n    debugPoints.push({\n      x: nx,\n      y: ny\n    });\n  };\n  const arcTo = (cx, cy, r, startAngle, arcAngle, sweepFlag) => {\n    const endAngle = startAngle + arcAngle;\n    const startX = cx + r * Math.cos(toRadians(startAngle));\n    const startY = cy + r * Math.sin(toRadians(startAngle));\n    const endX = cx + r * Math.cos(toRadians(endAngle));\n    const endY = cy + r * Math.sin(toRadians(endAngle));\n    path.push(`M ${startX} ${startY}`);\n    path.push(`A ${r} ${r} 0 ${Math.abs(arcAngle) > 180 ? 1 : 0} ${sweepFlag} ${endX} ${endY}`);\n    debugPoints.push({\n      x: endX,\n      y: endY\n    });\n    return {\n      x: endX,\n      y: endY\n    };\n  };\n\n  // Primer punto\n  moveTo(x, y);\n  for (const ms of orderedMiniSectors) {\n    const length = ms.length_cm / 100;\n    const curvature = ms.curvature_radius_cm / 100;\n    if (curvature === 0) {\n      // Recta\n      const rad = toRadians(angle);\n      const nx = x + length * Math.cos(rad);\n      const ny = y + length * Math.sin(rad);\n      lineTo(nx, ny);\n      x = nx;\n      y = ny;\n    } else {\n      var _ms$arc_angle_deg;\n      // Curva\n      const arcAngle = (_ms$arc_angle_deg = ms.arc_angle_deg) !== null && _ms$arc_angle_deg !== void 0 ? _ms$arc_angle_deg : 180;\n      const sweepFlag = ms.curve_direction === 'clockwise' ? 1 : 0;\n      const sign = ms.curve_direction === 'clockwise' ? 1 : -1;\n      const theta = toRadians(angle);\n      const dx = curvature * Math.cos(theta + sign * Math.PI / 2);\n      const dy = curvature * Math.sin(theta + sign * Math.PI / 2);\n      const cx = x + dx;\n      const cy = y + dy;\n      const result = arcTo(cx, cy, curvature, angle - 90 * sign, sign * arcAngle, sweepFlag);\n      x = result.x;\n      y = result.y;\n      angle += sign * arcAngle;\n      angle = (angle + 360) % 360;\n    }\n  }\n  const bounds = {\n    minX: Math.min(...debugPoints.map(p => p.x)),\n    maxX: Math.max(...debugPoints.map(p => p.x)),\n    minY: Math.min(...debugPoints.map(p => p.y)),\n    maxY: Math.max(...debugPoints.map(p => p.y))\n  };\n  const startLine = {\n    x: debugPoints[0].x,\n    y: debugPoints[0].y,\n    angle: angle\n  };\n  return {\n    path: path.join(' '),\n    startLine,\n    debugPoints,\n    bounds\n  };\n}","map":{"version":3,"names":["generateCircuitSVG","sectors","miniSectors","path","debugPoints","x","y","angle","toRadians","deg","Math","PI","orderedMiniSectors","flatMap","sector","mini_sector_ids","map","id","find","ms","filter","Boolean","moveTo","nx","ny","push","lineTo","arcTo","cx","cy","r","startAngle","arcAngle","sweepFlag","endAngle","startX","cos","startY","sin","endX","endY","abs","length","length_cm","curvature","curvature_radius_cm","rad","_ms$arc_angle_deg","arc_angle_deg","curve_direction","sign","theta","dx","dy","result","bounds","minX","min","p","maxX","max","minY","maxY","startLine","join"],"sources":["C:/Users/gerar/Documents/Proyectos/Racing Manager/V1/frontend/src/utils/generateCircuitSVG.js"],"sourcesContent":["export function generateCircuitSVG(sectors, miniSectors) {\r\n    const path = [];\r\n    const debugPoints = [];\r\n    let x = 0, y = 0;\r\n    let angle = 0; // en grados\r\n  \r\n    const toRadians = deg => deg * Math.PI / 180;\r\n    //const toDegrees = rad => rad * 180 / Math.PI;\r\n  \r\n    // Usamos los mini sectores en el orden que definan los sectores\r\n    const orderedMiniSectors = sectors\r\n      .flatMap(sector => sector.mini_sector_ids)\r\n      .map(id => miniSectors.find(ms => ms.id === id))\r\n      .filter(Boolean);\r\n  \r\n    const moveTo = (nx, ny) => {\r\n      path.push(`M ${nx} ${ny}`);\r\n      debugPoints.push({ x: nx, y: ny });\r\n    };\r\n  \r\n    const lineTo = (nx, ny) => {\r\n      path.push(`L ${nx} ${ny}`);\r\n      debugPoints.push({ x: nx, y: ny });\r\n    };\r\n  \r\n    const arcTo = (cx, cy, r, startAngle, arcAngle, sweepFlag) => {\r\n      const endAngle = startAngle + arcAngle;\r\n      const startX = cx + r * Math.cos(toRadians(startAngle));\r\n      const startY = cy + r * Math.sin(toRadians(startAngle));\r\n      const endX = cx + r * Math.cos(toRadians(endAngle));\r\n      const endY = cy + r * Math.sin(toRadians(endAngle));\r\n      path.push(`M ${startX} ${startY}`);\r\n      path.push(`A ${r} ${r} 0 ${Math.abs(arcAngle) > 180 ? 1 : 0} ${sweepFlag} ${endX} ${endY}`);\r\n      debugPoints.push({ x: endX, y: endY });\r\n      return { x: endX, y: endY };\r\n    };\r\n  \r\n    // Primer punto\r\n    moveTo(x, y);\r\n  \r\n    for (const ms of orderedMiniSectors) {\r\n      const length = ms.length_cm / 100;\r\n      const curvature = ms.curvature_radius_cm / 100;\r\n  \r\n      if (curvature === 0) {\r\n        // Recta\r\n        const rad = toRadians(angle);\r\n        const nx = x + length * Math.cos(rad);\r\n        const ny = y + length * Math.sin(rad);\r\n        lineTo(nx, ny);\r\n        x = nx;\r\n        y = ny;\r\n      } else {\r\n        // Curva\r\n        const arcAngle = (ms.arc_angle_deg ?? 180);\r\n        const sweepFlag = ms.curve_direction === 'clockwise' ? 1 : 0;\r\n        const sign = ms.curve_direction === 'clockwise' ? 1 : -1;\r\n  \r\n        const theta = toRadians(angle);\r\n        const dx = curvature * Math.cos(theta + sign * Math.PI / 2);\r\n        const dy = curvature * Math.sin(theta + sign * Math.PI / 2);\r\n        const cx = x + dx;\r\n        const cy = y + dy;\r\n  \r\n        const result = arcTo(cx, cy, curvature, angle - 90 * sign, sign * arcAngle, sweepFlag);\r\n        x = result.x;\r\n        y = result.y;\r\n        angle += sign * arcAngle;\r\n        angle = (angle + 360) % 360;\r\n      }\r\n    }\r\n  \r\n    const bounds = {\r\n      minX: Math.min(...debugPoints.map(p => p.x)),\r\n      maxX: Math.max(...debugPoints.map(p => p.x)),\r\n      minY: Math.min(...debugPoints.map(p => p.y)),\r\n      maxY: Math.max(...debugPoints.map(p => p.y))\r\n    };\r\n  \r\n    const startLine = {\r\n      x: debugPoints[0].x,\r\n      y: debugPoints[0].y,\r\n      angle: angle\r\n    };\r\n  \r\n    return {\r\n      path: path.join(' '),\r\n      startLine,\r\n      debugPoints,\r\n      bounds\r\n    };\r\n  }\r\n  "],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}