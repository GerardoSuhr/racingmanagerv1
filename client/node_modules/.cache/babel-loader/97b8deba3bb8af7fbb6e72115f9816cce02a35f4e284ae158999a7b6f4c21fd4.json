{"ast":null,"code":"export function generateCircuitSVG(sectors,miniSectors){var _options$speed;let options=arguments.length>2&&arguments[2]!==undefined?arguments[2]:{};const padding=50;const points=[];const speeds=[];let x=0;let y=0;let angle=0;let previousWasCurve=false;const carSpeedKmh=(_options$speed=options.speed)!==null&&_options$speed!==void 0?_options$speed:100;const intervalMs=30;const getSpeedFactor=radius=>{if(!radius)return 1;return Math.min(0.99,Math.max(0.5,(radius-100)/200*(0.99-0.5)+0.5));};const toRadians=deg=>deg*Math.PI/180;const addPoint=(px,py,speed)=>{points.push({x:px,y:py});speeds.push(speed);};const orderedMiniSectors=sectors.flatMap(sector=>sector.mini_sector_ids.map(id=>miniSectors.find(ms=>ms.id===id))).filter(Boolean);const sectorStartData=[];for(let i=0;i<orderedMiniSectors.length;i++){const ms=orderedMiniSectors[i];const length=ms.length_cm/100;const radius=ms.curvature_radius_cm/100;const speedFactor=getSpeedFactor(radius);const speedKmh=carSpeedKmh*speedFactor;const speedMps=speedKmh*1000/3600;const distancePerStep=speedMps*(intervalMs/1000);// Guardar punto de inicio de cada sector\nfor(let s=0;s<sectors.length;s++){const sector=sectors[s];const firstMiniSectorId=sector.mini_sector_ids[0];if(ms.id===firstMiniSectorId){sectorStartData.push({x,y,index:points.length});break;}}if(radius===0){if(typeof ms.direction==='number'&&!isNaN(ms.direction)&&!previousWasCurve){angle=ms.direction;}const dx=length*Math.cos(toRadians(angle));const dy=length*Math.sin(toRadians(angle));const steps=Math.max(1,Math.floor(length/distancePerStep));for(let j=0;j<=steps;j++){const px=x+dx*j/steps;const py=y+dy*j/steps;addPoint(px,py,speedKmh);}x+=dx;y+=dy;}else{var _ms$arc_angle_deg;const arcAngle=(_ms$arc_angle_deg=ms.arc_angle_deg)!==null&&_ms$arc_angle_deg!==void 0?_ms$arc_angle_deg:180;const steps=Math.max(1,Math.floor(radius*toRadians(arcAngle)/distancePerStep));const clockwise=ms.curve_direction==='clockwise';const sign=clockwise?-1:1;const startAngle=toRadians(angle);const cx=x+radius*Math.cos(startAngle+sign*Math.PI/2);const cy=y+radius*Math.sin(startAngle+sign*Math.PI/2);for(let j=1;j<=steps;j++){const theta=toRadians(arcAngle)*(j/steps);const angleStep=startAngle+sign*theta;const px=cx+radius*Math.cos(angleStep-sign*Math.PI/2);const py=cy+radius*Math.sin(angleStep-sign*Math.PI/2);addPoint(px,py,speedKmh);}const endAngle=startAngle+sign*toRadians(arcAngle);x=cx+radius*Math.cos(endAngle-sign*Math.PI/2);y=cy+radius*Math.sin(endAngle-sign*Math.PI/2);angle+=sign*arcAngle;}previousWasCurve=radius!==0;}const minX=Math.min(...points.map(p=>p.x));const minY=Math.min(...points.map(p=>p.y));const maxX=Math.max(...points.map(p=>p.x));const maxY=Math.max(...points.map(p=>p.y));const offsetX=padding-minX;const offsetY=padding-minY;const translatedPoints=points.map(p=>({x:p.x+offsetX,y:p.y+offsetY}));const translatedStartData=sectorStartData.map(p=>({x:p.x+offsetX,y:p.y+offsetY,index:p.index}));const svgPathFromPoints=pts=>{if(!pts.length)return'';let d=`M ${pts[0].x} ${pts[0].y}`;for(let i=1;i<pts.length;i++){d+=` L ${pts[i].x} ${pts[i].y}`;}return d;};const startLine={x1:translatedPoints[0].x-5,y1:translatedPoints[0].y-5,x2:translatedPoints[0].x+5,y2:translatedPoints[0].y+5};return{path:svgPathFromPoints(translatedPoints),startLine,bounds:{width:maxX-minX+2*padding,height:maxY-minY+2*padding,minX,minY},carPoints:translatedPoints,carSpeeds:speeds,sectorStartPoints:translatedStartData};}","map":{"version":3,"names":["generateCircuitSVG","sectors","miniSectors","_options$speed","options","arguments","length","undefined","padding","points","speeds","x","y","angle","previousWasCurve","carSpeedKmh","speed","intervalMs","getSpeedFactor","radius","Math","min","max","toRadians","deg","PI","addPoint","px","py","push","orderedMiniSectors","flatMap","sector","mini_sector_ids","map","id","find","ms","filter","Boolean","sectorStartData","i","length_cm","curvature_radius_cm","speedFactor","speedKmh","speedMps","distancePerStep","s","firstMiniSectorId","index","direction","isNaN","dx","cos","dy","sin","steps","floor","j","_ms$arc_angle_deg","arcAngle","arc_angle_deg","clockwise","curve_direction","sign","startAngle","cx","cy","theta","angleStep","endAngle","minX","p","minY","maxX","maxY","offsetX","offsetY","translatedPoints","translatedStartData","svgPathFromPoints","pts","d","startLine","x1","y1","x2","y2","path","bounds","width","height","carPoints","carSpeeds","sectorStartPoints"],"sources":["C:/Users/gerar/Documents/Proyectos/Racing Manager/racingmanagerV1/client/src/utils/generateCircuitSVG.js"],"sourcesContent":["export function generateCircuitSVG(sectors, miniSectors, options = {}) {\r\n  const padding = 50;\r\n  const points = [];\r\n  const speeds = [];\r\n\r\n  let x = 0;\r\n  let y = 0;\r\n  let angle = 0;\r\n  let previousWasCurve = false;\r\n\r\n  const carSpeedKmh = options.speed ?? 100;\r\n  const intervalMs = 30;\r\n\r\n  const getSpeedFactor = (radius) => {\r\n    if (!radius) return 1;\r\n    return Math.min(0.99, Math.max(0.5, ((radius - 100) / 200) * (0.99 - 0.5) + 0.5));\r\n  };\r\n\r\n  const toRadians = (deg) => (deg * Math.PI) / 180;\r\n\r\n  const addPoint = (px, py, speed) => {\r\n    points.push({ x: px, y: py });\r\n    speeds.push(speed);\r\n  };\r\n\r\n  const orderedMiniSectors = sectors\r\n    .flatMap(sector => sector.mini_sector_ids.map(id => miniSectors.find(ms => ms.id === id)))\r\n    .filter(Boolean);\r\n\r\n  const sectorStartData = [];\r\n\r\n  for (let i = 0; i < orderedMiniSectors.length; i++) {\r\n    const ms = orderedMiniSectors[i];\r\n    const length = ms.length_cm / 100;\r\n    const radius = ms.curvature_radius_cm / 100;\r\n    const speedFactor = getSpeedFactor(radius);\r\n    const speedKmh = carSpeedKmh * speedFactor;\r\n    const speedMps = speedKmh * 1000 / 3600;\r\n    const distancePerStep = speedMps * (intervalMs / 1000);\r\n\r\n    // Guardar punto de inicio de cada sector\r\n    for (let s = 0; s < sectors.length; s++) {\r\n      const sector = sectors[s];\r\n      const firstMiniSectorId = sector.mini_sector_ids[0];\r\n      if (ms.id === firstMiniSectorId) {\r\n        sectorStartData.push({ x, y, index: points.length });\r\n        break;\r\n      }\r\n    }\r\n\r\n    if (radius === 0) {\r\n      if (\r\n        typeof ms.direction === 'number' &&\r\n        !isNaN(ms.direction) &&\r\n        !previousWasCurve\r\n      ) {\r\n        angle = ms.direction;\r\n      }\r\n\r\n      const dx = length * Math.cos(toRadians(angle));\r\n      const dy = length * Math.sin(toRadians(angle));\r\n      const steps = Math.max(1, Math.floor(length / distancePerStep));\r\n\r\n      for (let j = 0; j <= steps; j++) {\r\n        const px = x + (dx * j) / steps;\r\n        const py = y + (dy * j) / steps;\r\n        addPoint(px, py, speedKmh);\r\n      }\r\n\r\n      x += dx;\r\n      y += dy;\r\n    } else {\r\n      const arcAngle = ms.arc_angle_deg ?? 180;\r\n      const steps = Math.max(1, Math.floor((radius * toRadians(arcAngle)) / distancePerStep));\r\n      const clockwise = ms.curve_direction === 'clockwise';\r\n      const sign = clockwise ? -1 : 1;\r\n\r\n      const startAngle = toRadians(angle);\r\n      const cx = x + radius * Math.cos(startAngle + sign * Math.PI / 2);\r\n      const cy = y + radius * Math.sin(startAngle + sign * Math.PI / 2);\r\n\r\n      for (let j = 1; j <= steps; j++) {\r\n        const theta = toRadians(arcAngle) * (j / steps);\r\n        const angleStep = startAngle + sign * theta;\r\n        const px = cx + radius * Math.cos(angleStep - sign * Math.PI / 2);\r\n        const py = cy + radius * Math.sin(angleStep - sign * Math.PI / 2);\r\n        addPoint(px, py, speedKmh);\r\n      }\r\n\r\n      const endAngle = startAngle + sign * toRadians(arcAngle);\r\n      x = cx + radius * Math.cos(endAngle - sign * Math.PI / 2);\r\n      y = cy + radius * Math.sin(endAngle - sign * Math.PI / 2);\r\n      angle += sign * arcAngle;\r\n    }\r\n\r\n    previousWasCurve = radius !== 0;\r\n  }\r\n\r\n  const minX = Math.min(...points.map(p => p.x));\r\n  const minY = Math.min(...points.map(p => p.y));\r\n  const maxX = Math.max(...points.map(p => p.x));\r\n  const maxY = Math.max(...points.map(p => p.y));\r\n\r\n  const offsetX = padding - minX;\r\n  const offsetY = padding - minY;\r\n\r\n  const translatedPoints = points.map(p => ({ x: p.x + offsetX, y: p.y + offsetY }));\r\n  const translatedStartData = sectorStartData.map(p => ({\r\n    x: p.x + offsetX,\r\n    y: p.y + offsetY,\r\n    index: p.index\r\n  }));\r\n\r\n  const svgPathFromPoints = (pts) => {\r\n    if (!pts.length) return '';\r\n    let d = `M ${pts[0].x} ${pts[0].y}`;\r\n    for (let i = 1; i < pts.length; i++) {\r\n      d += ` L ${pts[i].x} ${pts[i].y}`;\r\n    }\r\n    return d;\r\n  };\r\n\r\n  const startLine = {\r\n    x1: translatedPoints[0].x - 5,\r\n    y1: translatedPoints[0].y - 5,\r\n    x2: translatedPoints[0].x + 5,\r\n    y2: translatedPoints[0].y + 5\r\n  };\r\n  \r\n  return {\r\n    path: svgPathFromPoints(translatedPoints),\r\n    startLine,\r\n    bounds: {\r\n      width: maxX - minX + 2 * padding,\r\n      height: maxY - minY + 2 * padding,\r\n      minX,\r\n      minY\r\n    },\r\n    carPoints: translatedPoints,\r\n    carSpeeds: speeds,\r\n    sectorStartPoints: translatedStartData\r\n  };\r\n}\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}