{"ast":null,"code":"export function generateCircuitSVG(sectors, miniSectors, options = {}) {\n  var _options$speed;\n  const padding = 50;\n  const points = [];\n  const speeds = [];\n  let x = 0;\n  let y = 0;\n  let angle = 0;\n  let previousWasCurve = false;\n  const carSpeedKmh = (_options$speed = options.speed) !== null && _options$speed !== void 0 ? _options$speed : 100;\n  const intervalMs = 30;\n  const getSpeedFactor = radius => {\n    if (!radius) return 1;\n    return Math.min(0.99, Math.max(0.5, (radius - 100) / 200 * (0.99 - 0.5) + 0.5));\n  };\n  const toRadians = deg => deg * Math.PI / 180;\n  const addPoint = (px, py, speed) => {\n    points.push({\n      x: px,\n      y: py\n    });\n    speeds.push(speed);\n  };\n  const orderedMiniSectors = sectors.flatMap(sector => sector.mini_sector_ids.map(id => miniSectors.find(ms => ms.id === id))).filter(Boolean);\n  const sectorStartData = [];\n  for (let i = 0; i < orderedMiniSectors.length; i++) {\n    const ms = orderedMiniSectors[i];\n    const length = ms.length_cm / 100;\n    const radius = ms.curvature_radius_cm / 100;\n    const speedFactor = getSpeedFactor(radius);\n    const speedKmh = carSpeedKmh * speedFactor;\n    const speedMps = speedKmh * 1000 / 3600;\n    const distancePerStep = speedMps * (intervalMs / 1000);\n\n    // Guardar punto de inicio de cada sector\n    for (let s = 0; s < sectors.length; s++) {\n      const sector = sectors[s];\n      const firstMiniSectorId = sector.mini_sector_ids[0];\n      if (ms.id === firstMiniSectorId) {\n        sectorStartData.push({\n          x,\n          y,\n          index: points.length\n        });\n        break;\n      }\n    }\n    if (radius === 0) {\n      if (typeof ms.direction === 'number' && !isNaN(ms.direction) && !previousWasCurve) {\n        angle = ms.direction;\n      }\n      const dx = length * Math.cos(toRadians(angle));\n      const dy = length * Math.sin(toRadians(angle));\n      const steps = Math.max(1, Math.floor(length / distancePerStep));\n      for (let j = 0; j <= steps; j++) {\n        const px = x + dx * j / steps;\n        const py = y + dy * j / steps;\n        addPoint(px, py, speedKmh);\n      }\n      x += dx;\n      y += dy;\n    } else {\n      var _ms$arc_angle_deg;\n      const arcAngle = (_ms$arc_angle_deg = ms.arc_angle_deg) !== null && _ms$arc_angle_deg !== void 0 ? _ms$arc_angle_deg : 180;\n      const steps = Math.max(1, Math.floor(radius * toRadians(arcAngle) / distancePerStep));\n      const clockwise = ms.curve_direction === 'clockwise';\n      const sign = clockwise ? -1 : 1;\n      const startAngle = toRadians(angle);\n      const cx = x + radius * Math.cos(startAngle + sign * Math.PI / 2);\n      const cy = y + radius * Math.sin(startAngle + sign * Math.PI / 2);\n      for (let j = 1; j <= steps; j++) {\n        const theta = toRadians(arcAngle) * (j / steps);\n        const angleStep = startAngle + sign * theta;\n        const px = cx + radius * Math.cos(angleStep - sign * Math.PI / 2);\n        const py = cy + radius * Math.sin(angleStep - sign * Math.PI / 2);\n        addPoint(px, py, speedKmh);\n      }\n      const endAngle = startAngle + sign * toRadians(arcAngle);\n      x = cx + radius * Math.cos(endAngle - sign * Math.PI / 2);\n      y = cy + radius * Math.sin(endAngle - sign * Math.PI / 2);\n      angle += sign * arcAngle;\n    }\n    previousWasCurve = radius !== 0;\n  }\n  const minX = Math.min(...points.map(p => p.x));\n  const minY = Math.min(...points.map(p => p.y));\n  const maxX = Math.max(...points.map(p => p.x));\n  const maxY = Math.max(...points.map(p => p.y));\n  const offsetX = padding - minX;\n  const offsetY = padding - minY;\n  const translatedPoints = points.map(p => ({\n    x: p.x + offsetX,\n    y: p.y + offsetY\n  }));\n  const translatedStartData = sectorStartData.map(p => ({\n    x: p.x + offsetX,\n    y: p.y + offsetY,\n    index: p.index\n  }));\n  const svgPathFromPoints = pts => {\n    if (!pts.length) return '';\n    let d = `M ${pts[0].x} ${pts[0].y}`;\n    for (let i = 1; i < pts.length; i++) {\n      d += ` L ${pts[i].x} ${pts[i].y}`;\n    }\n    return d;\n  };\n  const startLine = {\n    x1: translatedPoints[0].x - 5,\n    y1: translatedPoints[0].y - 5,\n    x2: translatedPoints[0].x + 5,\n    y2: translatedPoints[0].y + 5\n  };\n  return {\n    path: svgPathFromPoints(translatedPoints),\n    startLine,\n    bounds: {\n      width: maxX - minX + 2 * padding,\n      height: maxY - minY + 2 * padding,\n      minX,\n      minY\n    },\n    carPoints: translatedPoints,\n    carSpeeds: speeds,\n    sectorStartPoints: translatedStartData\n  };\n}","map":{"version":3,"names":["generateCircuitSVG","sectors","miniSectors","options","_options$speed","padding","points","speeds","x","y","angle","previousWasCurve","carSpeedKmh","speed","intervalMs","getSpeedFactor","radius","Math","min","max","toRadians","deg","PI","addPoint","px","py","push","orderedMiniSectors","flatMap","sector","mini_sector_ids","map","id","find","ms","filter","Boolean","sectorStartData","i","length","length_cm","curvature_radius_cm","speedFactor","speedKmh","speedMps","distancePerStep","s","firstMiniSectorId","index","direction","isNaN","dx","cos","dy","sin","steps","floor","j","_ms$arc_angle_deg","arcAngle","arc_angle_deg","clockwise","curve_direction","sign","startAngle","cx","cy","theta","angleStep","endAngle","minX","p","minY","maxX","maxY","offsetX","offsetY","translatedPoints","translatedStartData","svgPathFromPoints","pts","d","startLine","x1","y1","x2","y2","path","bounds","width","height","carPoints","carSpeeds","sectorStartPoints"],"sources":["C:/Users/gerar/Documents/Proyectos/Racing Manager/RacingManagerV1/client/src/utils/generateCircuitSVG.js"],"sourcesContent":["export function generateCircuitSVG(sectors, miniSectors, options = {}) {\r\n  const padding = 50;\r\n  const points = [];\r\n  const speeds = [];\r\n\r\n  let x = 0;\r\n  let y = 0;\r\n  let angle = 0;\r\n  let previousWasCurve = false;\r\n\r\n  const carSpeedKmh = options.speed ?? 100;\r\n  const intervalMs = 30;\r\n\r\n  const getSpeedFactor = (radius) => {\r\n    if (!radius) return 1;\r\n    return Math.min(0.99, Math.max(0.5, ((radius - 100) / 200) * (0.99 - 0.5) + 0.5));\r\n  };\r\n\r\n  const toRadians = (deg) => (deg * Math.PI) / 180;\r\n\r\n  const addPoint = (px, py, speed) => {\r\n    points.push({ x: px, y: py });\r\n    speeds.push(speed);\r\n  };\r\n\r\n  const orderedMiniSectors = sectors\r\n    .flatMap(sector => sector.mini_sector_ids.map(id => miniSectors.find(ms => ms.id === id)))\r\n    .filter(Boolean);\r\n\r\n  const sectorStartData = [];\r\n\r\n  for (let i = 0; i < orderedMiniSectors.length; i++) {\r\n    const ms = orderedMiniSectors[i];\r\n    const length = ms.length_cm / 100;\r\n    const radius = ms.curvature_radius_cm / 100;\r\n    const speedFactor = getSpeedFactor(radius);\r\n    const speedKmh = carSpeedKmh * speedFactor;\r\n    const speedMps = speedKmh * 1000 / 3600;\r\n    const distancePerStep = speedMps * (intervalMs / 1000);\r\n\r\n    // Guardar punto de inicio de cada sector\r\n    for (let s = 0; s < sectors.length; s++) {\r\n      const sector = sectors[s];\r\n      const firstMiniSectorId = sector.mini_sector_ids[0];\r\n      if (ms.id === firstMiniSectorId) {\r\n        sectorStartData.push({ x, y, index: points.length });\r\n        break;\r\n      }\r\n    }\r\n\r\n    if (radius === 0) {\r\n      if (\r\n        typeof ms.direction === 'number' &&\r\n        !isNaN(ms.direction) &&\r\n        !previousWasCurve\r\n      ) {\r\n        angle = ms.direction;\r\n      }\r\n\r\n      const dx = length * Math.cos(toRadians(angle));\r\n      const dy = length * Math.sin(toRadians(angle));\r\n      const steps = Math.max(1, Math.floor(length / distancePerStep));\r\n\r\n      for (let j = 0; j <= steps; j++) {\r\n        const px = x + (dx * j) / steps;\r\n        const py = y + (dy * j) / steps;\r\n        addPoint(px, py, speedKmh);\r\n      }\r\n\r\n      x += dx;\r\n      y += dy;\r\n    } else {\r\n      const arcAngle = ms.arc_angle_deg ?? 180;\r\n      const steps = Math.max(1, Math.floor((radius * toRadians(arcAngle)) / distancePerStep));\r\n      const clockwise = ms.curve_direction === 'clockwise';\r\n      const sign = clockwise ? -1 : 1;\r\n\r\n      const startAngle = toRadians(angle);\r\n      const cx = x + radius * Math.cos(startAngle + sign * Math.PI / 2);\r\n      const cy = y + radius * Math.sin(startAngle + sign * Math.PI / 2);\r\n\r\n      for (let j = 1; j <= steps; j++) {\r\n        const theta = toRadians(arcAngle) * (j / steps);\r\n        const angleStep = startAngle + sign * theta;\r\n        const px = cx + radius * Math.cos(angleStep - sign * Math.PI / 2);\r\n        const py = cy + radius * Math.sin(angleStep - sign * Math.PI / 2);\r\n        addPoint(px, py, speedKmh);\r\n      }\r\n\r\n      const endAngle = startAngle + sign * toRadians(arcAngle);\r\n      x = cx + radius * Math.cos(endAngle - sign * Math.PI / 2);\r\n      y = cy + radius * Math.sin(endAngle - sign * Math.PI / 2);\r\n      angle += sign * arcAngle;\r\n    }\r\n\r\n    previousWasCurve = radius !== 0;\r\n  }\r\n\r\n  const minX = Math.min(...points.map(p => p.x));\r\n  const minY = Math.min(...points.map(p => p.y));\r\n  const maxX = Math.max(...points.map(p => p.x));\r\n  const maxY = Math.max(...points.map(p => p.y));\r\n\r\n  const offsetX = padding - minX;\r\n  const offsetY = padding - minY;\r\n\r\n  const translatedPoints = points.map(p => ({ x: p.x + offsetX, y: p.y + offsetY }));\r\n  const translatedStartData = sectorStartData.map(p => ({\r\n    x: p.x + offsetX,\r\n    y: p.y + offsetY,\r\n    index: p.index\r\n  }));\r\n\r\n  const svgPathFromPoints = (pts) => {\r\n    if (!pts.length) return '';\r\n    let d = `M ${pts[0].x} ${pts[0].y}`;\r\n    for (let i = 1; i < pts.length; i++) {\r\n      d += ` L ${pts[i].x} ${pts[i].y}`;\r\n    }\r\n    return d;\r\n  };\r\n\r\n  const startLine = {\r\n    x1: translatedPoints[0].x - 5,\r\n    y1: translatedPoints[0].y - 5,\r\n    x2: translatedPoints[0].x + 5,\r\n    y2: translatedPoints[0].y + 5\r\n  };\r\n  \r\n  return {\r\n    path: svgPathFromPoints(translatedPoints),\r\n    startLine,\r\n    bounds: {\r\n      width: maxX - minX + 2 * padding,\r\n      height: maxY - minY + 2 * padding,\r\n      minX,\r\n      minY\r\n    },\r\n    carPoints: translatedPoints,\r\n    carSpeeds: speeds,\r\n    sectorStartPoints: translatedStartData\r\n  };\r\n}\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}