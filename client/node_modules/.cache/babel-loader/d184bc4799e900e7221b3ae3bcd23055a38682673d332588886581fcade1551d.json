{"ast":null,"code":"export function generateCircuitSVG(sectors, miniSectors) {\n  const path = [];\n  const debugPoints = [];\n  let x = 0,\n    y = 0;\n  let angle = 0; // en grados\n\n  const toRadians = deg => deg * Math.PI / 180;\n  const toDegrees = rad => rad * 180 / Math.PI;\n\n  // Usamos los mini sectores en el orden que definan los sectores\n  const orderedMiniSectors = sectors.flatMap(sector => sector.mini_sector_ids).map(id => miniSectors.find(ms => ms.id === id)).filter(Boolean);\n  const moveTo = (nx, ny) => {\n    path.push(`M ${nx} ${ny}`);\n    debugPoints.push({\n      x: nx,\n      y: ny\n    });\n  };\n  const lineTo = (nx, ny) => {\n    path.push(`L ${nx} ${ny}`);\n    debugPoints.push({\n      x: nx,\n      y: ny\n    });\n  };\n  const arcTo = (cx, cy, r, startAngle, arcAngle, sweepFlag) => {\n    const endAngle = startAngle + arcAngle;\n    const startX = cx + r * Math.cos(toRadians(startAngle));\n    const startY = cy + r * Math.sin(toRadians(startAngle));\n    const endX = cx + r * Math.cos(toRadians(endAngle));\n    const endY = cy + r * Math.sin(toRadians(endAngle));\n    path.push(`M ${startX} ${startY}`);\n    path.push(`A ${r} ${r} 0 ${Math.abs(arcAngle) > 180 ? 1 : 0} ${sweepFlag} ${endX} ${endY}`);\n    debugPoints.push({\n      x: endX,\n      y: endY\n    });\n    return {\n      x: endX,\n      y: endY\n    };\n  };\n\n  // Primer punto\n  moveTo(x, y);\n  for (const ms of orderedMiniSectors) {\n    const length = ms.length_cm / 100;\n    const curvature = ms.curvature_radius_cm / 100;\n    if (curvature === 0) {\n      // Recta\n      const rad = toRadians(angle);\n      const nx = x + length * Math.cos(rad);\n      const ny = y + length * Math.sin(rad);\n      lineTo(nx, ny);\n      x = nx;\n      y = ny;\n    } else {\n      var _ms$arc_angle_deg;\n      // Curva\n      const arcAngle = (_ms$arc_angle_deg = ms.arc_angle_deg) !== null && _ms$arc_angle_deg !== void 0 ? _ms$arc_angle_deg : 180;\n      const sweepFlag = ms.curve_direction === 'clockwise' ? 1 : 0;\n      const sign = ms.curve_direction === 'clockwise' ? 1 : -1;\n      const theta = toRadians(angle);\n      const dx = curvature * Math.cos(theta + sign * Math.PI / 2);\n      const dy = curvature * Math.sin(theta + sign * Math.PI / 2);\n      const cx = x + dx;\n      const cy = y + dy;\n      const result = arcTo(cx, cy, curvature, angle - 90 * sign, sign * arcAngle, sweepFlag);\n      x = result.x;\n      y = result.y;\n      angle += sign * arcAngle;\n      angle = (angle + 360) % 360;\n    }\n  }\n  const bounds = {\n    minX: Math.min(...debugPoints.map(p => p.x)),\n    maxX: Math.max(...debugPoints.map(p => p.x)),\n    minY: Math.min(...debugPoints.map(p => p.y)),\n    maxY: Math.max(...debugPoints.map(p => p.y))\n  };\n  const startLine = {\n    x: debugPoints[0].x,\n    y: debugPoints[0].y,\n    angle: angle\n  };\n  return {\n    path: path.join(' '),\n    startLine,\n    debugPoints,\n    bounds\n  };\n}","map":{"version":3,"names":["generateCircuitSVG","sectors","miniSectors","path","debugPoints","x","y","angle","toRadians","deg","Math","PI","toDegrees","rad","orderedMiniSectors","flatMap","sector","mini_sector_ids","map","id","find","ms","filter","Boolean","moveTo","nx","ny","push","lineTo","arcTo","cx","cy","r","startAngle","arcAngle","sweepFlag","endAngle","startX","cos","startY","sin","endX","endY","abs","length","length_cm","curvature","curvature_radius_cm","_ms$arc_angle_deg","arc_angle_deg","curve_direction","sign","theta","dx","dy","result","bounds","minX","min","p","maxX","max","minY","maxY","startLine","join"],"sources":["C:/Users/gerar/Documents/Proyectos/Racing Manager/V1/frontend/src/utils/generateCircuitSVG.js"],"sourcesContent":["export function generateCircuitSVG(sectors, miniSectors) {\r\n    const path = [];\r\n    const debugPoints = [];\r\n    let x = 0, y = 0;\r\n    let angle = 0; // en grados\r\n  \r\n    const toRadians = deg => deg * Math.PI / 180;\r\n    const toDegrees = rad => rad * 180 / Math.PI;\r\n  \r\n    // Usamos los mini sectores en el orden que definan los sectores\r\n    const orderedMiniSectors = sectors\r\n      .flatMap(sector => sector.mini_sector_ids)\r\n      .map(id => miniSectors.find(ms => ms.id === id))\r\n      .filter(Boolean);\r\n  \r\n    const moveTo = (nx, ny) => {\r\n      path.push(`M ${nx} ${ny}`);\r\n      debugPoints.push({ x: nx, y: ny });\r\n    };\r\n  \r\n    const lineTo = (nx, ny) => {\r\n      path.push(`L ${nx} ${ny}`);\r\n      debugPoints.push({ x: nx, y: ny });\r\n    };\r\n  \r\n    const arcTo = (cx, cy, r, startAngle, arcAngle, sweepFlag) => {\r\n      const endAngle = startAngle + arcAngle;\r\n      const startX = cx + r * Math.cos(toRadians(startAngle));\r\n      const startY = cy + r * Math.sin(toRadians(startAngle));\r\n      const endX = cx + r * Math.cos(toRadians(endAngle));\r\n      const endY = cy + r * Math.sin(toRadians(endAngle));\r\n      path.push(`M ${startX} ${startY}`);\r\n      path.push(`A ${r} ${r} 0 ${Math.abs(arcAngle) > 180 ? 1 : 0} ${sweepFlag} ${endX} ${endY}`);\r\n      debugPoints.push({ x: endX, y: endY });\r\n      return { x: endX, y: endY };\r\n    };\r\n  \r\n    // Primer punto\r\n    moveTo(x, y);\r\n  \r\n    for (const ms of orderedMiniSectors) {\r\n      const length = ms.length_cm / 100;\r\n      const curvature = ms.curvature_radius_cm / 100;\r\n  \r\n      if (curvature === 0) {\r\n        // Recta\r\n        const rad = toRadians(angle);\r\n        const nx = x + length * Math.cos(rad);\r\n        const ny = y + length * Math.sin(rad);\r\n        lineTo(nx, ny);\r\n        x = nx;\r\n        y = ny;\r\n      } else {\r\n        // Curva\r\n        const arcAngle = (ms.arc_angle_deg ?? 180);\r\n        const sweepFlag = ms.curve_direction === 'clockwise' ? 1 : 0;\r\n        const sign = ms.curve_direction === 'clockwise' ? 1 : -1;\r\n  \r\n        const theta = toRadians(angle);\r\n        const dx = curvature * Math.cos(theta + sign * Math.PI / 2);\r\n        const dy = curvature * Math.sin(theta + sign * Math.PI / 2);\r\n        const cx = x + dx;\r\n        const cy = y + dy;\r\n  \r\n        const result = arcTo(cx, cy, curvature, angle - 90 * sign, sign * arcAngle, sweepFlag);\r\n        x = result.x;\r\n        y = result.y;\r\n        angle += sign * arcAngle;\r\n        angle = (angle + 360) % 360;\r\n      }\r\n    }\r\n  \r\n    const bounds = {\r\n      minX: Math.min(...debugPoints.map(p => p.x)),\r\n      maxX: Math.max(...debugPoints.map(p => p.x)),\r\n      minY: Math.min(...debugPoints.map(p => p.y)),\r\n      maxY: Math.max(...debugPoints.map(p => p.y))\r\n    };\r\n  \r\n    const startLine = {\r\n      x: debugPoints[0].x,\r\n      y: debugPoints[0].y,\r\n      angle: angle\r\n    };\r\n  \r\n    return {\r\n      path: path.join(' '),\r\n      startLine,\r\n      debugPoints,\r\n      bounds\r\n    };\r\n  }\r\n  "],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}