{"ast":null,"code":"const SCALE = 0.01; // 1 cm = 0.01 px\n\nexport function generateCircuitSVG(sectors, allMiniSectors) {\n  if (!sectors || sectors.length === 0) return {\n    path: '',\n    startLine: null,\n    debugPoints: []\n  };\n  const firstSector = sectors[0];\n  const firstMiniSectorId = firstSector.mini_sector_ids[0];\n  const firstMini = allMiniSectors.find(ms => ms.id === firstMiniSectorId);\n  let x = 300;\n  let y = 200;\n  let angle = 0;\n  let d = `M ${x} ${y}`;\n  let debugPoints = [{\n    x,\n    y\n  }];\n  let startLine = null;\n  for (let sector of allMiniSectors) {\n    const isCurve = sector.curvature_radius_cm > 0;\n    if (sector.id === firstMini.id) {\n      startLine = {\n        x,\n        y,\n        angle\n      };\n    }\n    if (!isCurve) {\n      var _sector$direction;\n      const length = sector.length_cm * SCALE;\n      const dx = Math.cos(angle * Math.PI / 180) * length;\n      const dy = Math.sin(angle * Math.PI / 180) * length;\n      x += dx;\n      y += dy;\n      d += ` L ${x} ${y}`;\n      angle = (_sector$direction = sector.direction) !== null && _sector$direction !== void 0 ? _sector$direction : angle;\n      debugPoints.push({\n        x,\n        y\n      });\n    } else {\n      var _sector$arc_angle_deg;\n      const radius = sector.curvature_radius_cm * SCALE;\n      const sweepFlag = sector.curve_direction === 'clockwise' ? 1 : 0;\n      const arcAngleDeg = (_sector$arc_angle_deg = sector.arc_angle_deg) !== null && _sector$arc_angle_deg !== void 0 ? _sector$arc_angle_deg : 180;\n      const arcAngleRad = arcAngleDeg * Math.PI / 180;\n      const largeArcFlag = arcAngleDeg > 180 ? 1 : 0;\n\n      // Calculamos el nuevo ángulo\n      const endAngle = angle + (sweepFlag === 1 ? arcAngleDeg : -arcAngleDeg);\n\n      // Punto final del arco desde posición actual\n      const dx = radius * 2 * Math.sin(arcAngleRad / 2) * Math.cos((angle + (sweepFlag === 1 ? arcAngleDeg : -arcAngleDeg)) * Math.PI / 180);\n      const dy = radius * 2 * Math.sin(arcAngleRad / 2) * Math.sin((angle + (sweepFlag === 1 ? arcAngleDeg : -arcAngleDeg)) * Math.PI / 180);\n      const endX = x + radius * 2 * Math.sin(arcAngleRad / 2) * Math.cos((angle + arcAngleDeg / 2) * Math.PI / 180);\n      const endY = y + radius * 2 * Math.sin(arcAngleRad / 2) * Math.sin((angle + arcAngleDeg / 2) * Math.PI / 180);\n\n      // Usamos fórmula fiable (más coherente con SVG y posición actual)\n      const thetaRad = angle * Math.PI / 180;\n      const endX2 = x + radius * Math.sin(arcAngleRad) * Math.cos(thetaRad + (sweepFlag === 1 ? arcAngleRad : -arcAngleRad));\n      const endY2 = y + radius * Math.sin(arcAngleRad) * Math.sin(thetaRad + (sweepFlag === 1 ? arcAngleRad : -arcAngleRad));\n\n      // MÁS simple aún: nos movemos a donde SVG lo necesita\n      const endX3 = x + radius * Math.sin(arcAngleRad) * Math.cos(thetaRad + (sweepFlag === 1 ? arcAngleRad : -arcAngleRad));\n      const endY3 = y + radius * Math.sin(arcAngleRad) * Math.sin(thetaRad + (sweepFlag === 1 ? arcAngleRad : -arcAngleRad));\n\n      // Pero lo más confiable: NO usar trigonometría. Usamos centro + SVG\n      const centerAngle = angle + (sweepFlag === 1 ? 90 : -90);\n      const cx = x + radius * Math.cos(centerAngle * Math.PI / 180);\n      const cy = y + radius * Math.sin(centerAngle * Math.PI / 180);\n      const endAngleFinal = angle + (sweepFlag === 1 ? arcAngleDeg : -arcAngleDeg);\n      const endXFinal = cx + radius * Math.cos((endAngleFinal + (sweepFlag === 1 ? -90 : 90)) * Math.PI / 180);\n      const endYFinal = cy + radius * Math.sin((endAngleFinal + (sweepFlag === 1 ? -90 : 90)) * Math.PI / 180);\n      d += ` A ${radius} ${radius} 0 ${largeArcFlag} ${sweepFlag} ${endXFinal} ${endYFinal}`;\n      x = endXFinal;\n      y = endYFinal;\n      angle = (endAngleFinal + 360) % 360;\n      debugPoints.push({\n        x,\n        y\n      });\n    }\n  }\n  return {\n    path: d,\n    startLine,\n    debugPoints\n  };\n}","map":{"version":3,"names":["SCALE","generateCircuitSVG","sectors","allMiniSectors","length","path","startLine","debugPoints","firstSector","firstMiniSectorId","mini_sector_ids","firstMini","find","ms","id","x","y","angle","d","sector","isCurve","curvature_radius_cm","_sector$direction","length_cm","dx","Math","cos","PI","dy","sin","direction","push","_sector$arc_angle_deg","radius","sweepFlag","curve_direction","arcAngleDeg","arc_angle_deg","arcAngleRad","largeArcFlag","endAngle","endX","endY","thetaRad","endX2","endY2","endX3","endY3","centerAngle","cx","cy","endAngleFinal","endXFinal","endYFinal"],"sources":["C:/Users/gerar/Documents/Proyectos/Racing Manager/V1/frontend/src/utils/generateCircuitSVG.js"],"sourcesContent":["const SCALE = 0.01; // 1 cm = 0.01 px\r\n\r\nexport function generateCircuitSVG(sectors, allMiniSectors) {\r\n  if (!sectors || sectors.length === 0) return { path: '', startLine: null, debugPoints: [] };\r\n\r\n  const firstSector = sectors[0];\r\n  const firstMiniSectorId = firstSector.mini_sector_ids[0];\r\n  const firstMini = allMiniSectors.find(ms => ms.id === firstMiniSectorId);\r\n\r\n  let x = 300;\r\n  let y = 200;\r\n  let angle = 0;\r\n  let d = `M ${x} ${y}`;\r\n  let debugPoints = [{ x, y }];\r\n  let startLine = null;\r\n\r\n  for (let sector of allMiniSectors) {\r\n    const isCurve = sector.curvature_radius_cm > 0;\r\n\r\n    if (sector.id === firstMini.id) {\r\n      startLine = { x, y, angle };\r\n    }\r\n\r\n    if (!isCurve) {\r\n      const length = sector.length_cm * SCALE;\r\n      const dx = Math.cos(angle * Math.PI / 180) * length;\r\n      const dy = Math.sin(angle * Math.PI / 180) * length;\r\n\r\n      x += dx;\r\n      y += dy;\r\n      d += ` L ${x} ${y}`;\r\n      angle = sector.direction ?? angle;\r\n\r\n      debugPoints.push({ x, y });\r\n    } else {\r\n      const radius = sector.curvature_radius_cm * SCALE;\r\n      const sweepFlag = sector.curve_direction === 'clockwise' ? 1 : 0;\r\n      const arcAngleDeg = sector.arc_angle_deg ?? 180;\r\n      const arcAngleRad = arcAngleDeg * Math.PI / 180;\r\n      const largeArcFlag = arcAngleDeg > 180 ? 1 : 0;\r\n\r\n      // Calculamos el nuevo ángulo\r\n      const endAngle = angle + (sweepFlag === 1 ? arcAngleDeg : -arcAngleDeg);\r\n\r\n      // Punto final del arco desde posición actual\r\n      const dx = radius * 2 * Math.sin(arcAngleRad / 2) * Math.cos((angle + (sweepFlag === 1 ? arcAngleDeg : -arcAngleDeg)) * Math.PI / 180);\r\n      const dy = radius * 2 * Math.sin(arcAngleRad / 2) * Math.sin((angle + (sweepFlag === 1 ? arcAngleDeg : -arcAngleDeg)) * Math.PI / 180);\r\n\r\n      const endX = x + radius * 2 * Math.sin(arcAngleRad / 2) * Math.cos((angle + arcAngleDeg / 2) * Math.PI / 180);\r\n      const endY = y + radius * 2 * Math.sin(arcAngleRad / 2) * Math.sin((angle + arcAngleDeg / 2) * Math.PI / 180);\r\n\r\n      // Usamos fórmula fiable (más coherente con SVG y posición actual)\r\n      const thetaRad = angle * Math.PI / 180;\r\n      const endX2 = x + radius * (Math.sin(arcAngleRad)) * Math.cos(thetaRad + (sweepFlag === 1 ? arcAngleRad : -arcAngleRad));\r\n      const endY2 = y + radius * (Math.sin(arcAngleRad)) * Math.sin(thetaRad + (sweepFlag === 1 ? arcAngleRad : -arcAngleRad));\r\n\r\n      // MÁS simple aún: nos movemos a donde SVG lo necesita\r\n      const endX3 = x + radius * (Math.sin(arcAngleRad)) * Math.cos(thetaRad + (sweepFlag === 1 ? arcAngleRad : -arcAngleRad));\r\n      const endY3 = y + radius * (Math.sin(arcAngleRad)) * Math.sin(thetaRad + (sweepFlag === 1 ? arcAngleRad : -arcAngleRad));\r\n\r\n      // Pero lo más confiable: NO usar trigonometría. Usamos centro + SVG\r\n      const centerAngle = angle + (sweepFlag === 1 ? 90 : -90);\r\n      const cx = x + radius * Math.cos(centerAngle * Math.PI / 180);\r\n      const cy = y + radius * Math.sin(centerAngle * Math.PI / 180);\r\n      const endAngleFinal = angle + (sweepFlag === 1 ? arcAngleDeg : -arcAngleDeg);\r\n      const endXFinal = cx + radius * Math.cos((endAngleFinal + (sweepFlag === 1 ? -90 : 90)) * Math.PI / 180);\r\n      const endYFinal = cy + radius * Math.sin((endAngleFinal + (sweepFlag === 1 ? -90 : 90)) * Math.PI / 180);\r\n\r\n      d += ` A ${radius} ${radius} 0 ${largeArcFlag} ${sweepFlag} ${endXFinal} ${endYFinal}`;\r\n\r\n      x = endXFinal;\r\n      y = endYFinal;\r\n      angle = (endAngleFinal + 360) % 360;\r\n\r\n      debugPoints.push({ x, y });\r\n    }\r\n  }\r\n\r\n  return { path: d, startLine, debugPoints };\r\n}"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}